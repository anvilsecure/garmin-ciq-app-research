# Out-of-bound String Loading
The `news` assembly instruction allows creating a new string referenced by a symbol. The symbol is resolved to a virtual address that is then converted to an offset within a section (code or data) where the string to load is located.

The `news` OP code checks that the string is located inside one of the following section:

- The program code section
- The program data section
- The API code section
- The API data section

However, `news` does not check that the end of the string is within the section. It is possible to craft a string located at the end of the section, with a size that goes beyond the section itself. When loading the string in memory, the firmware could disclose memory.

```c
e_tvm_error TVM:vm:tvm_vm:opcode_news(s_tvm_ctx *ctx)
{
// [...]
  pc = ctx->pc_ptr;
  // [...]
  tvmaddr_b1 = *pc;
  ctx->pc_ptr = pc + 1;
  tvmaddr_b2 = pc[1];
  ctx->pc_ptr = pc + 2;
  tvmaddr_b3 = pc[2];
  ctx->pc_ptr = pc + 3;
  tvmaddr_b4 = pc[3];
  ctx->pc_ptr = pc + 4;
  // [...]
  // Anvil: Pass the symbol parameter to the function
  tvm_value_load_string(ctx,CONCAT31(CONCAT21(CONCAT11(tvmaddr_b1,tvmaddr_b2),tvmaddr_b3),tvmaddr_b4),ctx->stack_ptr);
  // [...]
}

e_tvm_error tvm_value_load_string(s_tvm_ctx *ctx,uint tvmaddr_str,undefined4 str_value_out)

{
  e_tvm_error eVar1;
  s_tvm_object_resource_string *ptr_str;

  // Anvil: The symbol is converted to a raw pointer
  eVar1 = tvm_tvmaddr_to_ptr(ctx,tvmaddr_str,(int *)&ptr_str);
  if (eVar1 == SUCCESS) {
    // Anvil: And the string is read from that raw location
    eVar1 = tvm_string_def_to_value(ctx,ptr_str,str_value_out,1);
  }
  return eVar1;
}

// Anvil: The function converts a virtual pointer to a raw pointer
// Anvil: It checks that the pointer starts within the corresponding section
// Anvil: However, there is no additional check, here or elsewhere, to ensure that the end of the string is within the section.
e_tvm_error tvm_tvmaddr_to_ptr(s_tvm_ctx *ctx,uint tvm_addr,int *ptr_addr_out)
{
  uint base_addr;
  uint end_of_section;
  
  base_addr = tvm_addr & 0xf0000000;
  if (base_addr == 0x10000000) {
    base_addr = ctx->code_section;
    end_of_section = ctx->section_code_length;
  }
  else if (base_addr < 0x10000001) {
    if (base_addr != 0) {
      return ILLEGAL_FRAME_ERROR;
    }
    base_addr = ctx->data_section;
    end_of_section = ctx->section_data_length;
  }
  else {
    if (base_addr == 0x20000000) {
      base_addr = ctx->api_data_section;
      if (ctx->api_data_section_end <= (tvm_addr & 0xfffffff)) {
        return ILLEGAL_ACCESS_OUT_OF_BOUNDS;
      }
      goto end;
    }
    if (base_addr != 0x30000000) {
      return ILLEGAL_FRAME_ERROR;
    }
    base_addr = ctx->api_code_section;
    end_of_section = ctx->api_code_section_end;
  }
  if (end_of_section <= (tvm_addr & 0xfffffff)) {
    return ILLEGAL_ACCESS_OUT_OF_BOUNDS;
  }
end:
  *ptr_addr_out = (tvm_addr & 0xfffffff) + base_addr;
  return SUCCESS;
}
```