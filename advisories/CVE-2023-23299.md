# Permission Bypass via Field Definition Manipulation
Garmin implements a permission system to restrict access to sensitive modules. An application can access sensitive modules by including their respective module IDs in its permissions section, inside the `PRG` file.

At runtime, Garmin checks that the module accessed by the application is in the permissions section. If the module is not in the list, the Virtual Machine (VM) denies access and aborts execution.

Based on reverse engineering, we understand that permissions are checked when calling the following MonkeyC opcodes:

- `getm`: to get a reference to a module
- `getv`: to resolve a symbol
- `putv`: to assign a new value to symbol

On principle, an application must get a reference to a module to call its methods. For instance, if we attempt to call the [`openWebPage`](https://developer.garmin.com/connect-iq/api-docs/Toybox/Communications.html#openWebPage-instance_function) of the `Toybox.Communications` module with:

```java
Communications.openWebPage("https://anvilsecure.com/", null, null);
```

The following MonkeyC assembly is generated:

```
spush Toybox_Communications
getm
spush openWebPage
getv
frpush
news @strhttps___anvilsecure_com__1744215192
npush
npush
invokem 4
```

When getting a reference to the `Toybox.Communications` module with `getm`, the VM checks the permissions. If our `PRG` file does not specify the module in its permissions section, we get the following error:

```
Error: Permission Required
Details: Permission for module 'Toybox.Communications' required
Stack:
  - onStart() at C:\Garmin\monkeyc\VirtualBypass\source\VirtualBypassApp.mc:19 0x100000fc
Encountered an app crash.
```

However, we found that we can skip the module resolution by directly manipulating the field definition of our own class, specified in the data section of the `PRG` file. The attack is to point our class field to directly call the function in the restricted module.

The field definition specifies a symbol and its value for a class field. The value is a virtual pointer that can point inside the `PRG`'s code and data sections, but also inside the SDK code and data sections, and the table of native functions (depending on its most significant byte). The ability to point a field definition to the SDK code or data section, or the table of native functions, can allow us to bypass the module resolution and call restricted functions directly.

For example, we can create a fake function called `fakeOpenWebPage` that mimics the prototype of the restricted `openWebPage` SDK function:

```java
class VirtualBypassApp extends Application.AppBase {

    function fakeOpenWebPage(url, params, options) as Void {
        return;
    }
    
    // [...]
```

Then, we tamper with the field definition of `fakeOpenWebPage` to specify the virtual pointer of the genuine `openWebPage` SDK function. The virtual pointer `0x40040033` is pointing to the genuine `openWebPage` SDK function. Its value is specific to the firmware version running on the device. In this example, the version is 9.0.0.

The tampered `PRG` file has zero permissions, and yet it successfully calls the `Toybox.Communications.openWebPage` restricted function. See the proof-of-concept application calling `openWebPage` without permissions: <https://github.com/anvilsecure/garmin-ciq-app-research/blob/main/poc/GRMN-13.prg>

The proof-of-concept presented above is simplistic and has limited impact since `openWebPage` is harmless. However, more advanced attacks are possible. For instance, a malicious `PRG` file could instantiate a restricted module by creating a fake `<init>` and `initialize` functions that will call the genuine module's functions directly.